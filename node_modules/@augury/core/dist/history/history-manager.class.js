export class HistoryManager {
    constructor() {
        this.elapsedEvents = [];
    }
    addEvent(event) {
        this.elapsedEvents.push(event);
    }
    clear() {
        this.elapsedEvents = [];
    }
    projectResults(projection, maxResults = null, startEventId = null, endEventId = null) {
        const results = [];
        for (let index = 0; index < this.elapsedEvents.length; index++) {
            if (maxResults !== null && results.length >= maxResults) {
                break;
            }
            if (this.eventFallsWithinRange(this.elapsedEvents[index], startEventId, endEventId) &&
                this.shouldCollectResult(this.elapsedEvents[index], projection, index)) {
                const result = projection.collectResult();
                if (result) {
                    results.push(result);
                }
            }
        }
        return results;
    }
    shouldCollectResult(event, projection, currentIndex) {
        return currentIndex === this.elapsedEvents.length - 1 || projection.process(event);
    }
    eventFallsWithinRange(event, startEventId, endEventId) {
        return ((startEventId === null && endEventId === null) || event.isIdInRange(startEventId, endEventId));
    }
}
//# sourceMappingURL=history-manager.class.js.map