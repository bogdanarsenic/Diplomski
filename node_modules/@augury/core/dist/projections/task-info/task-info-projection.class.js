import { RootTaskCompletedEvent, RootTaskInvokedEvent, ZoneTaskCompletedEvent, ZoneTaskInvokedEvent, } from '../../events';
import { EventProjection } from '../event-projection.class';
export class TaskInfoProjection extends EventProjection {
    constructor() {
        super(...arguments);
        this.taskInfo = {};
        this.isTaskExecuting = false;
    }
    process(event) {
        if (event.isInstanceOf(ZoneTaskInvokedEvent) || event.isInstanceOf(RootTaskInvokedEvent)) {
            const taskEvent = event;
            this.taskInfo = {
                zone: event.isInstanceOf(ZoneTaskInvokedEvent) ? 'ng' : 'root',
                task: taskEvent.task,
                startEventId: event.id,
                startTimestamp: event.timePeriod.startTimestamp,
                drag: 0,
            };
            this.isTaskExecuting = true;
        }
        if (this.isTaskExecuting) {
            this.taskInfo.drag += event.getAuguryDrag();
            if (event.isInstanceOf(ZoneTaskCompletedEvent) ||
                event.isInstanceOf(RootTaskCompletedEvent)) {
                this.taskInfo = Object.assign({}, this.taskInfo, { endTimestamp: event.timePeriod.startTimestamp });
                return true;
            }
        }
        return false;
    }
    getResult() {
        return this.taskInfo;
    }
    cleanup() {
        this.taskInfo = {};
        this.isTaskExecuting = false;
    }
}
//# sourceMappingURL=task-info-projection.class.js.map