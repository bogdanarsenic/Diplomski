import { MethodCompletedEvent, MethodInvokedEvent } from '../../events/method-events';
import { Probe } from '../probe.class';
import { getAllObjectsInAngularApplication, getComponentsFromModule, getServicesFromModule, } from '../types';
import { AngularClassType } from './angular-class-type.enum';
export class ModuleMethodsProbe extends Probe {
    doInitialize(ngZone, ngModule) {
        this.ngModule = ngModule;
        const components = getAllObjectsInAngularApplication(getComponentsFromModule, this.ngModule);
        const services = getAllObjectsInAngularApplication(getServicesFromModule, this.ngModule);
        const probe = this;
        function wrapMethod(Class, methodName, classType) {
            const originalMethod = Class.prototype[methodName];
            Class.prototype[methodName] = function (...parameters) {
                probe.emit(() => new MethodInvokedEvent(classType, Class, this, methodName, parameters));
                const returnValue = originalMethod.apply(this, parameters);
                probe.emit(() => new MethodCompletedEvent(classType, Class, this, methodName, returnValue));
                return returnValue;
            };
            Class.prototype[methodName].__augury_wrapped__ = true;
        }
        function shouldWrapMethod(Class, propertyName) {
            if (propertyName === 'constructor') {
                return false;
            }
            // TODO: some prototype members use getters/setters
            const propDesc = Object.getOwnPropertyDescriptor(Class.prototype, propertyName);
            if (propDesc && propDesc.get) {
                return false;
            }
            const property = Class.prototype[propertyName];
            return (typeof property === 'function' &&
                !property.__added_by_augury__ &&
                !property.__augury_wrapped__);
        }
        function wrapClassMethods(Class, classType) {
            Object.getOwnPropertyNames(Class.prototype).forEach(propertyName => {
                if (shouldWrapMethod(Class, propertyName)) {
                    wrapMethod(Class, propertyName, classType);
                }
            });
        }
        services.forEach(Service => wrapClassMethods(Service, AngularClassType.Service));
        components.forEach(Component => wrapClassMethods(Component, AngularClassType.Component));
    }
}
//# sourceMappingURL=module-methods-probe.class.js.map